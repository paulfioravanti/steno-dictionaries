"""
Q&A Dictionary

This dictionary containing briefs related to switching between different people
or lines of questioning in a conversation.
"""
from typing import Any, List

# Length of the longest supported key (number of strokes).
LONGEST_KEY = 2

# Key formatting/grammar markers
_QUESTION_MARKER = "{?}"
_STATEMENT_MARKER = "{.}"
_INTERRUPT_MARKER = "--"
_SPACE = "{^ ^}"
_YIELD = "\n"
# REF: https://github.com/openstenoproject/plover/wiki/Dictionary-Format#capitalize-next-word
_CAP_NEXT_WORD = "{^}{-|}"

_END_QUESTION = _QUESTION_MARKER + _YIELD
_END_STATEMENT = _STATEMENT_MARKER + _YIELD
_INTERRUPT = _INTERRUPT_MARKER + _YIELD

# Speakers
_PLAINTIFF_LAWYER_1_NAME = "MR. STPHAO" # aka "Mr. Snoo"
_DEFENSE_LAWYER_1_NAME = "MR. EUFPLT"   # aka "Mr. Ifpelt"

_PLAINTIFF_LAWYER_2_NAME = "MR. SKWRAO" # aka "Mr. Screw"
_DEFENSE_LAWYER_2_NAME = "MR. EURBGS"   # aka "Mr. Irbs"

_WITNESS_NAME = "THE WITNESS"
_COURT_NAME = "THE COURT"
_VIDEOGRAPHER_NAME = "THE VIDEOGRAPHER"
_COURT_REPORTER_NAME = "THE COURT REPORTER"
_CLERK_NAME = "THE CLERK"
_BAILIFF_NAME = "THE BAILIFF"

_PRE_SPEAKER_FORMATTING = "\t"
_POST_SPEAKER_FORMATTING = "{^:  }"

def _formatted_speaker(speaker):
    return (
        _PRE_SPEAKER_FORMATTING
        + speaker
        + _POST_SPEAKER_FORMATTING
        + _CAP_NEXT_WORD
    )

_PLAINTIFF_LAWYER_1 = _formatted_speaker(_PLAINTIFF_LAWYER_1_NAME)
_PLAINTIFF_LAWYER_1_FOLLOWING_QUESTION = _END_QUESTION + _PLAINTIFF_LAWYER_1
_PLAINTIFF_LAWYER_1_FOLLOWING_STATEMENT = _END_STATEMENT + _PLAINTIFF_LAWYER_1
_PLAINTIFF_LAWYER_1_INTERRUPTING = _INTERRUPT + _PLAINTIFF_LAWYER_1

_PLAINTIFF_LAWYER_2 = _formatted_speaker(_PLAINTIFF_LAWYER_2_NAME)
_PLAINTIFF_LAWYER_2_FOLLOWING_QUESTION = _END_QUESTION + _PLAINTIFF_LAWYER_2
_PLAINTIFF_LAWYER_2_FOLLOWING_STATEMENT = _END_STATEMENT + _PLAINTIFF_LAWYER_2
_PLAINTIFF_LAWYER_2_INTERRUPTING = _INTERRUPT + _PLAINTIFF_LAWYER_2

_DEFENSE_LAWYER_1 = _formatted_speaker(_DEFENSE_LAWYER_1_NAME)
_DEFENSE_LAWYER_1_FOLLOWING_QUESTION = _END_QUESTION + _DEFENSE_LAWYER_1
_DEFENSE_LAWYER_1_FOLLOWING_STATEMENT = _END_STATEMENT + _DEFENSE_LAWYER_1
_DEFENSE_LAWYER_1_INTERRUPTING = _INTERRUPT + _DEFENSE_LAWYER_1

_DEFENSE_LAWYER_2 = _formatted_speaker(_DEFENSE_LAWYER_2_NAME)
_DEFENSE_LAWYER_2_FOLLOWING_QUESTION = _END_QUESTION + _DEFENSE_LAWYER_2
_DEFENSE_LAWYER_2_FOLLOWING_STATEMENT = _END_STATEMENT + _DEFENSE_LAWYER_2
_DEFENSE_LAWYER_2_INTERRUPTING = _INTERRUPT + _DEFENSE_LAWYER_2

_WITNESS = _formatted_speaker(_WITNESS_NAME)
_WITNESS_FOLLOWING_QUESTION = _END_QUESTION + _WITNESS
_WITNESS_FOLLOWING_STATEMENT = _END_STATEMENT + _WITNESS
_WITNESS_INTERRUPTING = _INTERRUPT + _WITNESS

_COURT = _formatted_speaker(_COURT_NAME)
_COURT_FOLLOWING_QUESTION = _END_QUESTION + _COURT
_COURT_FOLLOWING_STATEMENT = _END_STATEMENT + _COURT
_COURT_INTERRUPTING = _INTERRUPT + _COURT

_VIDEOGRAPHER = _formatted_speaker(_VIDEOGRAPHER_NAME)
_VIDEOGRAPHER_FOLLOWING_QUESTION = _END_QUESTION + _VIDEOGRAPHER
_VIDEOGRAPHER_FOLLOWING_STATEMENT = _END_STATEMENT + _VIDEOGRAPHER
_VIDEOGRAPHER_INTERRUPTING = _INTERRUPT + _VIDEOGRAPHER

_COURT_REPORTER = _formatted_speaker(_COURT_REPORTER_NAME)
_COURT_REPORTER_FOLLOWING_QUESTION = _END_QUESTION + _COURT_REPORTER
_COURT_REPORTER_FOLLOWING_STATEMENT = _END_STATEMENT + _COURT_REPORTER
_COURT_REPORTER_INTERRUPTING = _INTERRUPT + _COURT_REPORTER

_CLERK = _formatted_speaker(_CLERK_NAME)
_CLERK_FOLLOWING_QUESTION = _END_QUESTION + _CLERK
_CLERK_FOLLOWING_STATEMENT = _END_STATEMENT + _CLERK
_CLERK_INTERRUPTING = _INTERRUPT + _CLERK

_BAILIFF = _formatted_speaker(_BAILIFF_NAME)
_BAILIFF_FOLLOWING_QUESTION = _END_QUESTION + _BAILIFF
_BAILIFF_FOLLOWING_STATEMENT = _END_STATEMENT + _BAILIFF
_BAILIFF_INTERRUPTING = _INTERRUPT + _BAILIFF

# Q&A markers
_Q_MARKER = "Q"
_A_MARKER = "A"
_PRE_QA_MARKER_FORMATTING = "\t"
_POST_QA_MARKER_FORMATTING = "\t"

def _formatted_qa_marker(qa_marker):
    return (
        _PRE_QA_MARKER_FORMATTING
        + qa_marker
        + _POST_QA_MARKER_FORMATTING
        + _CAP_NEXT_WORD
    )

_QUESTION = _formatted_qa_marker(_Q_MARKER)
_ANSWER = _formatted_qa_marker(_A_MARKER)

_QUESTION_FOLLOWING_QUESTION = _END_QUESTION + _QUESTION
_QUESTION_FOLLOWING_STATEMENT = _END_STATEMENT + _QUESTION
_QUESTION_INTERRUPTING = _INTERRUPT + _QUESTION

_ANSWER_FOLLOWING_QUESTION = _END_QUESTION + _ANSWER
_ANSWER_FOLLOWING_STATEMENT = _END_STATEMENT + _ANSWER
_ANSWER_INTERRUPTING = _INTERRUPT + _ANSWER

# Bylines
_BYLINE_MARKER = "BY "
_PRE_BYLINE_FORMATTING = ""
_POST_BYLINE_FORMATTING = ":\n"

def _formatted_byline(speaker):
    return (
        _PRE_BYLINE_FORMATTING
        + _BYLINE_MARKER
        + speaker
        + _POST_BYLINE_FORMATTING
        + _QUESTION
    )

_BYLINE_PLAINTIFF_LAWYER_1 = _formatted_byline(_PLAINTIFF_LAWYER_1_NAME)
_BYLINE_PLAINTIFF_LAWYER_2 = _formatted_byline(_PLAINTIFF_LAWYER_2_NAME)
_BYLINE_DEFENSE_LAWYER_1 = _formatted_byline(_DEFENSE_LAWYER_1_NAME)
_BYLINE_DEFENSE_LAWYER_2 = _formatted_byline(_DEFENSE_LAWYER_2_NAME)

_BYLINE_PLAINTIFF_LAWYER_1_FOLLOWING_QUESTION = (
    _END_QUESTION + _BYLINE_PLAINTIFF_LAWYER_1
)
_BYLINE_PLAINTIFF_LAWYER_1_FOLLOWING_STATEMENT = (
    _END_STATEMENT + _BYLINE_PLAINTIFF_LAWYER_1
)
_BYLINE_PLAINTIFF_LAWYER_1_INTERRUPTING = (
    _INTERRUPT + _BYLINE_PLAINTIFF_LAWYER_1
)
_BYLINE_PLAINTIFF_LAWYER_2_FOLLOWING_QUESTION = (
    _END_QUESTION + _BYLINE_PLAINTIFF_LAWYER_2
)
_BYLINE_PLAINTIFF_LAWYER_2_FOLLOWING_STATEMENT = (
    _END_STATEMENT + _BYLINE_PLAINTIFF_LAWYER_2
)
_BYLINE_PLAINTIFF_LAWYER_2_INTERRUPTING = (
    _INTERRUPT + _BYLINE_PLAINTIFF_LAWYER_2
)
_BYLINE_DEFENSE_LAWYER_1_FOLLOWING_QUESTION = (
    _END_QUESTION + _BYLINE_DEFENSE_LAWYER_1
)
_BYLINE_DEFENSE_LAWYER_1_FOLLOWING_STATEMENT = (
    _END_STATEMENT + _BYLINE_DEFENSE_LAWYER_1
)
_BYLINE_DEFENSE_LAWYER_1_INTERRUPTING = (
    _INTERRUPT + _BYLINE_DEFENSE_LAWYER_1
)
_BYLINE_DEFENSE_LAWYER_2_FOLLOWING_QUESTION = (
    _END_QUESTION + _BYLINE_DEFENSE_LAWYER_2
)
_BYLINE_DEFENSE_LAWYER_2_FOLLOWING_STATEMENT = (
    _END_STATEMENT + _BYLINE_DEFENSE_LAWYER_2
)
_BYLINE_DEFENSE_LAWYER_2_INTERRUPTING = (
    _INTERRUPT + _BYLINE_DEFENSE_LAWYER_2
)

# Immediate Response Phrases
_ALL_RIGHT = "All right"
_CORRECT = "Correct"
_I_DONT_KNOW = "I don't know"
_NO = "No"
_NO_SIR = "No, sir"
_OKAY = "Okay"
_RIGHT = "Right"
_SURE = "Sure"
_UH_HUH = "Uh-huh"
_YEAH = "Yeah"
_YES = "Yes"
_YES_SIR = "Yes, sir"

def _elaborate(statement):
    return statement + _STATEMENT_MARKER + _SPACE + _CAP_NEXT_WORD

def _yield_following_answer(answer):
    return answer + _END_STATEMENT + _QUESTION

def _yield_following_question(question):
    return question + _END_QUESTION + _ANSWER

_ALL_RIGHT_ELABORATE = _elaborate(_ALL_RIGHT)
_ALL_RIGHT_YIELD = _yield_following_question(_ALL_RIGHT)
_OKAY_ELABORATE = _elaborate(_OKAY)
_OKAY_YIELD = _yield_following_question(_OKAY)

_CORRECT_ELABORATE = _elaborate(_CORRECT)
_CORRECT_YIELD = _yield_following_answer(_CORRECT)
_I_DONT_KNOW_ELABORATE = _elaborate(_I_DONT_KNOW)
_I_DONT_KNOW_YIELD = _yield_following_answer(_I_DONT_KNOW)
_NO_ELABORATE = _elaborate(_NO)
_NO_YIELD = _yield_following_answer(_NO)
_NO_SIR_ELABORATE = _elaborate(_NO_SIR)
_NO_SIR_YIELD = _yield_following_answer(_NO_SIR)
_RIGHT_ELABORATE = _elaborate(_RIGHT)
_RIGHT_YIELD = _yield_following_answer(_RIGHT)
_SURE_ELABORATE = _elaborate(_SURE)
_SURE_YIELD = _yield_following_answer(_SURE)
_UH_HUH_ELABORATE = _elaborate(_UH_HUH)
_UH_HUH_YIELD = _yield_following_answer(_UH_HUH)
_YEAH_ELABORATE = _elaborate(_YEAH)
_YEAH_YIELD = _yield_following_answer(_YEAH)
_YES_ELABORATE = _elaborate(_YES)
_YES_YIELD = _yield_following_answer(_YES)
_YES_SIR_ELABORATE = _elaborate(_YES_SIR)
_YES_SIR_YIELD = _yield_following_answer(_YES_SIR)

_OUTLINES = {
    # Questions: using NCRA `STKPWHR` outline
    "STKPWHR": _QUESTION_FOLLOWING_STATEMENT,
    "STKPWHR*": _QUESTION,
    "STKPWHR-F": _QUESTION_FOLLOWING_QUESTION,
    "STKPWHR-R": _QUESTION_FOLLOWING_STATEMENT,
    "STKPWHR-RB": _QUESTION_INTERRUPTING,
    # Answers: using NCRA `-FRPBLGTS` outline
    "-FRPBLGTS": _ANSWER_FOLLOWING_QUESTION,
    "H-FRPBLGTS": _ANSWER_FOLLOWING_QUESTION,
    "R-FRPBLGTS": _ANSWER_FOLLOWING_STATEMENT,
    "WR-FRPBLGTS": _ANSWER_INTERRUPTING,
    # Plaintiff Lawyer 1 ("Mr. Snoo"): using NCRA `STPHAO` outline
    "STPHAO": _PLAINTIFF_LAWYER_1,
    "STPHAO*": _BYLINE_PLAINTIFF_LAWYER_1,
    "STPHAO*F": _BYLINE_PLAINTIFF_LAWYER_1_FOLLOWING_QUESTION,
    "STPHAO*R": _BYLINE_PLAINTIFF_LAWYER_1_FOLLOWING_STATEMENT,
    "STPHAO*RB": _BYLINE_PLAINTIFF_LAWYER_1_INTERRUPTING,
    "STPHAOF": _PLAINTIFF_LAWYER_1_FOLLOWING_QUESTION,
    "STPHAOR": _PLAINTIFF_LAWYER_1_FOLLOWING_STATEMENT,
    "STPHAORB": _PLAINTIFF_LAWYER_1_INTERRUPTING,
    # Plaintiff Lawyer 2 ("Mr. Screw"): using NCRA `SKWRAO` outline
    "SKWRAO": _PLAINTIFF_LAWYER_2,
    "SKWRAO*": _BYLINE_PLAINTIFF_LAWYER_2,
    "SKWRAO*F": _BYLINE_PLAINTIFF_LAWYER_2_FOLLOWING_QUESTION,
    "SKWRAO*R": _BYLINE_PLAINTIFF_LAWYER_2_FOLLOWING_STATEMENT,
    "SKWRAO*RB": _BYLINE_PLAINTIFF_LAWYER_2_INTERRUPTING,
    "SKWRAOF": _PLAINTIFF_LAWYER_2_FOLLOWING_QUESTION,
    "SKWRAOR": _PLAINTIFF_LAWYER_2_FOLLOWING_STATEMENT,
    "SKWRAORB": _PLAINTIFF_LAWYER_2_INTERRUPTING,
    # Defense Lawyer 1 ("Mr. Ifpelt"): using NCRA `EUFPLT` outline
    "*EUFPLT": _BYLINE_DEFENSE_LAWYER_1,
    "EUFPLT": _DEFENSE_LAWYER_1,
    "H*EUFPLT": _BYLINE_DEFENSE_LAWYER_1_FOLLOWING_QUESTION,
    "HEUFPLT": _DEFENSE_LAWYER_1_FOLLOWING_QUESTION,
    "R*EUFPLT": _BYLINE_DEFENSE_LAWYER_1_FOLLOWING_STATEMENT,
    "REUFPLT": _DEFENSE_LAWYER_1_FOLLOWING_STATEMENT,
    "WR*EUFPLT": _BYLINE_DEFENSE_LAWYER_1_INTERRUPTING,
    "WREUFPLT": _DEFENSE_LAWYER_1_INTERRUPTING,
    # Defense Lawyer 2 ("Mr. Irbs"): using NCRA `EURBGS` outline
    "*EURBGS": _BYLINE_DEFENSE_LAWYER_2,
    "EURBGS": _DEFENSE_LAWYER_2,
    "H*EURBGS": _BYLINE_DEFENSE_LAWYER_2_FOLLOWING_QUESTION,
    "HEURBGS": _DEFENSE_LAWYER_2_FOLLOWING_QUESTION,
    "R*EURBGS": _BYLINE_DEFENSE_LAWYER_2_FOLLOWING_STATEMENT,
    "REURBGS": _DEFENSE_LAWYER_2_FOLLOWING_STATEMENT,
    "WR*EURBGS": _BYLINE_DEFENSE_LAWYER_2_INTERRUPTING,
    "WREURBGS": _DEFENSE_LAWYER_2_INTERRUPTING,
    # The Witness: using NCRA `W-PBS/W-PBS` outline
    "W-PBS/W-PBS": _WITNESS,
    "WH-PBS/WH-PBS": _WITNESS_FOLLOWING_QUESTION,
    "WR*PBS/WR*PBS": _WITNESS_INTERRUPTING,
    "WR-PBS/WR-PBS": _WITNESS_FOLLOWING_STATEMENT,
    # The Witness: using custom `SKWRAOEURBGS` outline
    "SKPWHRAOEURBGS": _WITNESS_INTERRUPTING,
    "SKWHRAOEURBGS": _WITNESS_FOLLOWING_QUESTION,
    "SKWRAO*EURBGS": _WITNESS_FOLLOWING_STATEMENT,
    "SKWRAOEUFRBGS": _WITNESS_FOLLOWING_QUESTION,
    "SKWRAOEUFRPBGS": _WITNESS_INTERRUPTING,
    "SKWRAOEURBGS": _WITNESS,
    # The Court: using NCRA `STPHAOEUFPLT` outline
    "STPHAO*EUFPLT": _COURT_FOLLOWING_QUESTION,
    "STPHAOEUFPLT": _COURT,
    "STPHAOEUFRPBLT": _COURT_INTERRUPTING,
    "STPHAOEUFRPLT": _COURT_FOLLOWING_STATEMENT,
    # The Videographer: using NCRA `SREUD/SREUD` outline
    "SR*EURD/SR*EURD": _VIDEOGRAPHER_INTERRUPTING,
    "SREUD/SREUD": _VIDEOGRAPHER,
    "SREUFD/SREUFD": _VIDEOGRAPHER_FOLLOWING_QUESTION,
    "SREURD/SREURD": _VIDEOGRAPHER_FOLLOWING_STATEMENT,
    # The Videographer: using custom `STPHAEUFPLT` outline
    "STPHA*EUFPLT": _VIDEOGRAPHER_FOLLOWING_QUESTION,
    "STPHAEUFPLT": _VIDEOGRAPHER,
    "STPHAEUFRPBLT": _VIDEOGRAPHER_INTERRUPTING,
    "STPHAEUFRPLT": _VIDEOGRAPHER_FOLLOWING_STATEMENT,
    # The Court Reporter: using NCRA `RORP/RORP` outline
    "RO*FRP/RO*FRP": _COURT_REPORTER_INTERRUPTING,
    "RO*RP/RO*RP": _COURT_REPORTER_FOLLOWING_STATEMENT,
    "ROFRP/ROFRP": _COURT_REPORTER_FOLLOWING_QUESTION,
    "RORP/RORP": _COURT_REPORTER,
    # The Court Reporter: using custom `STPHOEUFPLT` outline
    "STPHO*EUFPLT": _COURT_REPORTER_FOLLOWING_QUESTION,
    "STPHOEUFPLT": _COURT_REPORTER,
    "STPHOEUFRPBLT": _COURT_REPORTER_INTERRUPTING,
    "STPHOEUFRPLT": _COURT_REPORTER_FOLLOWING_STATEMENT,
    # The Clerk: using NCRA `KHRERBG/KHRERBG` outline
    "KHR*ERBG/KHR*ERBG": _CLERK_FOLLOWING_STATEMENT,
    "KHREFRBG/KHREFRBG": _CLERK_FOLLOWING_QUESTION,
    "KHREFRPBG/KHREFRPBG": _CLERK_INTERRUPTING,
    "KHRERBG/KHRERBG": _CLERK,
    # The Clerk: using custom `STPHAOEFPLT` outline
    "STPHAO*EFPLT": _CLERK_FOLLOWING_QUESTION,
    "STPHAOEFPLT": _CLERK,
    "STPHAOEFRPBLT": _CLERK_INTERRUPTING,
    "STPHAOEFRPLT": _CLERK_FOLLOWING_STATEMENT,
    # The Bailiff: using NCRA `PWHR-F/PWHR-F` outline
    "PWHR*F/PWHR*F": _BAILIFF_FOLLOWING_QUESTION,
    "PWHR*FR/PWHR*FR": _BAILIFF_INTERRUPTING,
    "PWHR-F/PWHR-F": _BAILIFF,
    "PWHR-FR/PWHR-FR": _BAILIFF_FOLLOWING_STATEMENT,
    # The Bailiff: using custom `STPHAOUFPLT` outline
    "STPHAO*UFPLT": _BAILIFF_FOLLOWING_QUESTION,
    "STPHAOUFPLT": _BAILIFF,
    "STPHAOUFRPBLT": _BAILIFF_INTERRUPTING,
    "STPHAOUFRPLT": _BAILIFF_FOLLOWING_STATEMENT,
    # Lawyer Statement + Elaborate: using NCRA `STKPWHR` outline
    "STKPWHR-BG": _QUESTION_FOLLOWING_STATEMENT + _OKAY_ELABORATE,
    "STKPWHR-RT": _QUESTION_FOLLOWING_STATEMENT + _ALL_RIGHT_ELABORATE,
    # Lawyer Question + Yield Control: using NCRA `STKPWHR` outline
    "STKPWHR*BG": _QUESTION_FOLLOWING_STATEMENT + _OKAY_YIELD,
    "STKPWHR*RT": _QUESTION_FOLLOWING_STATEMENT + _ALL_RIGHT_YIELD,
    # Witness Answer + Elaborate: using NCRA `-FRPBLGTS` outline
    "HUFRPBLGTS": _ANSWER_FOLLOWING_QUESTION + _UH_HUH_ELABORATE,
    "KR-FRPBLGTS": _ANSWER_FOLLOWING_QUESTION + _CORRECT_ELABORATE,
    "KWR-FRPBLGTS": _ANSWER_FOLLOWING_QUESTION + _YES_ELABORATE,
    "KWREFRPBLGTS": _ANSWER_FOLLOWING_QUESTION + _YEAH_ELABORATE,
    "KWROEFRPBLGTS": _ANSWER_FOLLOWING_QUESTION + _I_DONT_KNOW_ELABORATE,
    "SH-FRPBLGTS": _ANSWER_FOLLOWING_QUESTION + _SURE_ELABORATE,
    "SKWR-FRPBLGTS": _ANSWER_FOLLOWING_QUESTION + _YES_SIR_ELABORATE,
    "STPH-FRPBLGTS": _ANSWER_FOLLOWING_QUESTION + _NO_SIR_ELABORATE,
    "TKPH-FRPBLGTS": _ANSWER_FOLLOWING_QUESTION + _I_DONT_KNOW_ELABORATE,
    "TPH-FRPBLGTS": _ANSWER_FOLLOWING_QUESTION + _NO_ELABORATE,
    "TR-FRPBLGTS": _ANSWER_FOLLOWING_QUESTION + _RIGHT_ELABORATE,
    # Witness Answer + Yield Control: using NCRA `-FRPBLGTS` outline
    "H*UFRPBLGTS": _ANSWER_FOLLOWING_QUESTION + _UH_HUH_YIELD,
    "KR*FRPBLGTS": _ANSWER_FOLLOWING_QUESTION + _CORRECT_YIELD,
    "KWR*EFRPBLGTS": _ANSWER_FOLLOWING_QUESTION + _YEAH_YIELD,
    "KWR*FRPBLGTS": _ANSWER_FOLLOWING_QUESTION + _YES_YIELD,
    "KWRO*EFRPBLGTS": _ANSWER_FOLLOWING_QUESTION + _I_DONT_KNOW_YIELD,
    "SH*FRPBLGTS": _ANSWER_FOLLOWING_QUESTION + _SURE_YIELD,
    "SKWR*FRPBLGTS": _ANSWER_FOLLOWING_QUESTION + _YES_SIR_YIELD,
    "STPH*FRPBLGTS": _ANSWER_FOLLOWING_QUESTION + _NO_SIR_YIELD,
    "TKPH*FRPBLGTS": _ANSWER_FOLLOWING_QUESTION + _I_DONT_KNOW_YIELD,
    "TPH*FRPBLGTS": _ANSWER_FOLLOWING_QUESTION + _NO_YIELD,
    "TR*FRPBLGTS": _ANSWER_FOLLOWING_QUESTION + _RIGHT_YIELD
}

# Lookup function: return the translation for <key> (a tuple of strokes)
# or raise KeyError if no translation is available/possible.
def lookup(key: List[str]) -> str:
    """
    Convert chorded Plover stroke into Q&A output
    """
    assert len(key) <= LONGEST_KEY, f"{len(key)}/{LONGEST_KEY}"
    return _OUTLINES["/".join(key)]

# Optional: return an array of stroke tuples that would translate back
# to <text> (an empty array if not possible).
def reverse_lookup(_text: str) -> List[Any]:
    """
    No reverse lookup provided
    """
    return []
